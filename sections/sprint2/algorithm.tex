For determining whether a route is a good fit, the system uses an algorithm.
This algorithm is based on a simplified version of how \citet{ghoseiri2011real} determines a match.
In the paper, they take many aspects into account when determining matches, such as smoking, gender and age preferences.
These are all valid but only the aspects that this algorithm focuses on are time and distance.

\subsubsection{The main algorithm}
Let us say we want to determine whether $A$ could pickup person $B$ on his way through route $r$ when person $B$ wants to go from his start position $s$ to his goal position $g$.
If $A$ could pick up $B$ then we want to know how good a match it is.

The algorithm should express this as a value from 0 to 1 which tells how close the match is where 0 is not a match and 1 is when it is literally \emph{on} the way there.

To summarize we have an algorithm  which takes in a route $r$ and two positions $s$ and $g$, and returns a value between 0 and 1.

In the algorithm, there are two aspects which need to be evaluated: Time and distance.
If we imagine that these have already been solved with a similar interface, where they take a route and two points as input and return a value from 0 to 1 depending on how close they match, but only considering one of the aspects.

If one of the aspects is deemed unacceptable by giving it a score of 0 then the whole match is unacceptable and is given the same final score.
From the scores, the average score could be expressed as $\frac{d+t}{2}$ where $d$ is the distance score and $t$ is the time score.
But to increase flexibility of the algorithm two constants are introduced $d_\gamma$ and $t_\gamma$.
These constant enables us to weight the time and distance score independent of each other by expanding the expression to $\frac{d\times d_\gamma+t\times t_\gamma}{d_\gamma+t_\gamma}$.

\begin{algorithm}
	\caption{The Time Distance Analyser pseudocode}
	\label{alg:timedistanalyser}
	\begin{algorithmic}[1]
		\Require 
		\Statex let $d_\gamma$ be the modifier for distance in $\mathbb{R}_{>0}$
		\Statex let $t_\gamma$ be the modifier for time in $\mathbb{R}_{>0}$
		\Statex 
		\Function{TimeDistanceAnalyser}{$r, s, g$}
			\State $d\gets$\Call{DistanceAnalyser}{$r, s, g$}
			\State $t\gets$\Call{TimeAnalyser}{$r, s, g$}
			
			\If{$d > 0 \wedge t > 0$}
				\State \Return $\frac{d\times d_\gamma+t\times t_\gamma}{d_\gamma+t_\gamma}$
			\Else
				\State\Return 0
			\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The final algorithm can be seen in Algorithm \ref{alg:timedistanalyser}.
Line 2 and 3 is the calls to the algorithms that solve the subproblems and line 4 to 8 is the logic that was explained in the previous paragraph.
The complexity of the algorithm is dependent on the two calls on line 2 and 3 because the rest of the algorithm is input independant and, therefore, $O(1)$ if we ignore line 2 and 3.

\subsubsection{Distance analyser}

Lets take a look at the sub problems.

First, we have the distance analyser, this algorithm takes a route and two end points and figures out the score for the detour when only considering the distance.
To do this we need to define how long the longest acceptable detour should be.
We also need a way of figuring out the distance between two disconnected locations. 
For this, the function for euclidian distances would work since it only gets significantly inaccurate on larger scales.
This means that we have the following function.
\begin{align*}
	dist : \mathbb{L}\times\mathbb{L} &\rightarrow \mathbb{R}_{\geq 0}\\
	a, b &\mapsto \sqrt{(a_{latitude} - b_{latitude})^2 + (a_{longtitude} - b_{longtitude})^2}
\end{align*}

In the function the symbol $\mathbb{L}$ is used to denote the set of all possible locations.


\begin{algorithm}
	\caption{The Distance Analyser pseudocode}
	\label{alg:distanalyser}
	\begin{algorithmic}[1]
		\Require 
		\Statex let $\beta$ be the largest acceptable detour length in $\mathbb{R}_{>0}$ 
		\Statex 
		\Function{DistanceAnalyser}{$r, s, g$}
			\State let $r_s$ be the closest point to $s$ in $r$
			\State let $r_g$ be the closest point to $g$ in $r$
			\State $d_s\gets 2\times dist(r_s, s)$\Comment Pickup detour distance
			\State $d_g\gets 2\times dist(r_g, g)$\Comment Set off detour distance
			\State\Return $1-\frac{d_s + d_g}{\beta}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The distance analyser algorithm, as seen in Algorithm \ref{alg:distanalyser}, finds the points on the route that are closest to the start and end points.
From those points, the algorithm approximates the detour required to take by the driver to pick up the passenger.
The approximation is rough as it assumes that the driver wants to drive back to the original road and that a direct path from the route to the start and goal point exists.
This makes the final score for the distance a pessimistic evaluation  of the detour needed.

The final score for the distance analyser is calculated by taking the total detour and dividing it by the length of the largest acceptable detour.
This results in a value between zero and one when the detour is less than the largest detour, and greater than one when the detour is longer.
We remember that Algorithm \ref{alg:timedistanalyser} expected a value that less than zero when it was deemed unacceptable, so the value is inverted by subtracting it from one.

Because of line 2 and 3, where the whole route should be iterated through, the complexity of the algorithm is $O(|r|)$ where $|r|$ is the number of points in $r$.
Line 4 to 6 perform arithmetic operations which run in constant time so they can be ignored.

\subsubsection{Time analyser}

The time analyser works in a similar way to the distance analyser. 
It also takes two points and a route and returns a score when only the time differences are considered.

When determining time difference two things should be taken into consideration: the time the detour takes and the existing differences in time.
The time the detour takes can be approximated by taking the time it takes to travel a distance unit and multiplying that with the distance of the detour.

Each point in the route has some information about when this point was visited.
We can use this to determine the relative time distance between two points by using the following function.
\begin{align*}
	time : \mathbb{L}\times\mathbb{L} &\rightarrow \mathbb{R}_{\geq 0}\\
	a, b &\mapsto | a_{time} - b_{time} |
\end{align*}

Now that we have the detour time and the relative time difference we can figure out how much of an inconvenience it is for on of the participants in this potential match.
From the driver's perspective (s)he has to start driving at the normal time minus the detour to still make it on time.
This makes the detour the only inconvenience.
If the other participant has to arrive earlier than (s)he would otherwise arrive then the driver would also have to take that into consideration making the inconvenience not only the detour but also the relative time.

From the passenger's perspective, the opposite is true when it comes to the relative time. 
It is only an inconvenience when the driver must set them off before they need to arrive.

It is also worth noting that if the relative time is the same as the time it takes to take the detour.
Then the only inconvenience for the driver is the detour.

This makes the formula for the total inconvenience when taking both participants into account is defined as follows.

\[ |d - t| + d \]

where $d$ is the detour and $t$ is the relative time.

Now, let us consider what would happen on the way back.
The situation is now that the driver and passenger want to go home, but they want to leave at a specific time.
The algorithm already solves this because if a specific arrival time is defined a specific departure time must also be defined.
And the differences in time must be the same.

\begin{algorithm}
	\caption{The Time Analyser pseudocode}
	\label{alg:timeanalyser}
	\begin{algorithmic}[1]
		\Require 
		\Statex let $\delta$ be the acceptable time difference in $\mathbb{R}_{>0}$
		\Statex let $\gamma$ be the translation from distance to time in $\mathbb{R}_{>0}$ 
		\Statex 
		\Function{TimeAnalyser}{$r, s, g$}
			\State let $r_s$ be the closest point to $s$ in $r$
			\State let $r_g$ be the closest point to $g$ in $r$
			\State $d \gets (2\times dist(r_s,s) + 2\times dist(r_g,g))\times\gamma$\Comment{The total detour time}
			\State $t \gets max(time(r_s, s), time(r_g, g))$\Comment{The largest time difference}
			\State\Return $1-\frac{|d - t| + d}{\delta}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Algorithm \ref{alg:timeanalyser} shows the pseudocode for the time analyser.
Line 2 to 4 is reminiscent of line 2 to 5 in Algorithm \ref{alg:distanalyser} with the difference that it sums the detours and multiplies the result with the distance to time translation.
Line 5 takes the greatest time difference between the closest points.
The reason for taking the greates value is the pessimistic approach again, and the delay will not be worse than that.

The complexity is the same as in Algorithm \ref{alg:distanalyser} because of the similarity of the first few lines and the last lines are simple arithmetic operations. 
The exceptions are $dist$, $time$, and $max$. 
$time$ and $dist$ have already been described in detail in this and previous section and are considered to be $O(1)$ operations.
$max$ takes in two values compares them and returns the largest of the two.
This is also a constant operation and with that, we can determine that the time analyser algorihm is $O(|r|)$.

This means that the main algorihm is also $O(|r|)$ which is eqviliant to $O(n)$.
