\subsection{Algorithm}
The system uses a custom developed algorithm to determine whether two routes are a good fit.
This algorithm is loosely based on a simplified version of \citet{ghoseiri2011real}, with regards to the process of the evaluation of a match.
In the paper, the algorithm considers multiple aspects when assessing matches, such as smoking, gender and age preferences.
The criteria are practical to some extent, but the focus of the \gls{rs} system are the time and distance criteria.
A position is spatial-temporal, whereas a location is a spatial point and a time is a temporal point.
A route is a chronological list of positions.

To show how the algorithm should work for different routes we introduce an example which can be seen on figure \ref{fig:algEx1}.
\begin{figure}[!ht]
    \centering
\input{figures/algorithmEx1.tex}
    \caption{Alice, Bob, Carol and Eve.}
    \label{fig:algEx1}
\end{figure}
The example introduces four user, each with one stable route in this example, in addition to the location of their routes, we also have their departure and arrival times, this can be seen in table \ref{timetable}.
\begin{table}[]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{User} & \textbf{Departure} & \textbf{Arrival} & \textbf{Distance} 	\\ \midrule
Alice         & 07:20                   & 07:55       & 36.5 km 			\\
Bob           & 07:35                   & 07:50       & 14 km  		  		\\
Carol         & 08:05                   & 08:30       & 15 km         		\\
Eve           & 07:30                   & 07:50       & 18 km         		\\ \bottomrule
\end{tabular}
\caption{The four users departure and arrival times as well as their distances.}
\label{timetable}
\end{table}

For this example, the goal will be to find out if any route matches with Alice's route $\{A_s-A_g\}$.

\subsubsection{Time Distance Analyser Algorithm}
To serve as an example, the algorithm should assess the score of Alice, on the way through route $r$, picking up person Bob, Carol or Eve, for each of their routes.
The score represents the match of the routes of Alice and each of the other, and should be expressed as a decimal value from 0 to 1 which tells how good the match is.
0 represents a bad match, a major detour or times not compatible, and 1 represents a perfect match, and requires no detour.
To enhance the flexibility of the algorithm, a comparison will both be made for a $r_1$ against $r_2$.
To summarize, the algorithm takes a route $r$ and two positions to compare against; start ($s$), and goal ($g$) as arguments
The algorithm then returns a decimal value between 0 and 1.

In the algorithm, there are two aspects to be evaluated: Time and distance.
These are assumed to be evaluated by two sub algorithms that both takes the route and two points as input and return a value from 0 to 1 depending on how closely they match..

If either time or distance is deemed unacceptable they are being assessed a score of 0, thus the whole match is unacceptable and given the a final score of 0.
From the scores of the sub algorithms, the final score can be expressed as the average score $\frac{d+t}{2}$, where $d$ is the distance score and $t$ is the time score.
To increase flexibility of the algorithm, two constants are introduced $d_\gamma$ and $t_\gamma$.
These constants enables weighting of the time and distance score independent of each other by expanding the expression to $\frac{d\times d_\gamma+t\times t_\gamma}{d_\gamma+t_\gamma}$.

For our example we simply set both $d_\gamma$ and $t_\gamma$ to 1. 

\begin{algorithm}
	\caption{The Time Distance Analyser Pseudocode}
	\label{alg:timedistanalyser}
	\begin{algorithmic}[1]
		\Require 
		\Statex let $d_\gamma$ be the modifier for distance in $\mathbb{R}_{>0}$
		\Statex let $t_\gamma$ be the modifier for time in $\mathbb{R}_{>0}$
		\Statex 
		\Function{TimeDistanceAnalyser}{$r, s, g$}
			\State $d\gets$\Call{DistanceAnalyser}{$r, s, g$}
			\State $t\gets$\Call{TimeAnalyser}{$r, s, g$}
			
			\If{$d > 0 \wedge t > 0$}
				\State \Return $\frac{d\times d_\gamma+t\times t_\gamma}{d_\gamma+t_\gamma}$
			\Else
				\State\Return 0
			\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The final algorithm can be seen in Algorithm \ref{alg:timedistanalyser}.
Line 2 and 3 are calls to the algorithms that solve the subproblems of scoring the time and location, and line 4 to 8 is the logic described in the previous paragraph.
%%The complexity of the algorithm is dependent on the calls on lines 2 and 3, because the rest of the algorithm is input independent, and therefore $O(1)$, if we ignore line 2 and 3.
The following sections will cover the subproblems.
First, the distance analyser algorithm will be described, followed by the time analyser algorithm.

\subsubsection{Distance analyser}
The distance analyser algorithm takes a route and two end points and assesses the score for the detour when only considering the distance.
To do this, it is required to define how long the longest acceptable detour should be.
The algorithm also needs a way of calculating the distance between two discrete locations, which can be performed by the function for euclidean distances.
This leads to the following algorithm, where the symbol $\mathbb{L}$ is used to denote the set of all possible locations:

\begin{align*}
	dist : \mathbb{L}\times\mathbb{L} &\rightarrow \mathbb{R}_{\geq 0}\\
	a, b &\mapsto \sqrt{(a_{latitude} - b_{latitude})^2 + (a_{longitude} - b_{longitude})^2}
\end{align*}

\begin{algorithm}
	\caption{The Distance Analyser pseudocode}
	\label{alg:distanalyser}
	\begin{algorithmic}[1]
		\Require 
		\Statex let $\beta$ be the largest acceptable detour length in $\mathbb{R}_{>0}$ 
		\Statex 
		\Function{DistanceAnalyser}{$r, s, g$}
			\State let $r_s$ be the closest point to $s$ in $r$
			\State let $r_g$ be the closest point to $g$ in $r$
			\State $d_s\gets 2\times dist(r_s, s)$\Comment Pickup detour distance
			\State $d_g\gets 2\times dist(r_g, g)$\Comment Set off detour distance
			\State\Return $1-\frac{d_s + d_g}{\beta}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The distance analyser algorithm, as seen in Algorithm \ref{alg:distanalyser}, finds the points on the route that are closest to the start and end points.
From those points, the algorithm approximates the detour required to take by the driver to pick up the passenger.
The approximation is rough as it assumes that the driver continues on the original route and that a direct path from the route to the start and goal point exists.
This makes the final score for the distance a pessimistic evaluation of the detour needed.

The final score for the distance analyser is calculated by taking the total detour length and dividing it by the length of the largest acceptable detour.
For the example introduced in the beginning of this chapter we set the longest detour to be 20\% of Alice's total commute. \todo{more here}
This results in a value between zero and one when the detour is less than the largest detour, and greater than one when the detour is longer.
We remember that Algorithm \ref{alg:timedistanalyser} expected a value that less than zero when it was deemed unacceptable, so the value is inverted by subtracting it from one.

%Because of line 2 and 3, where the whole route should be iterated through, the complexity of the algorithm is $O(|r|)$ where $|r|$ is the number of positions in route $r$.
Line 4 to 6 perform arithmetic operations that run in constant time, and can be ignored when describing the asymptotic notation.

\subsubsection{Time analyser}
The time analyser algorithm works similarly as the distance analyser algorithm. 
It is also designed to take two points and a route as input and to return a score of only the time differences.

When determining time difference two things should be taken into consideration: the detour duration and the existing differences in time.
The detour duration can be approximated by multiplying the detour distance with the time it takes to travel a distance unit.

Each position in the route has information about when the location was visited.
This can be used to determine the relative time distance between two points by using the following function:
\begin{align*}
	time : \mathbb{L}\times\mathbb{L} &\rightarrow \mathbb{R}_{\geq 0}\\
	a, b &\mapsto | a_{time} - b_{time} |
\end{align*}

The calculated detour time and relative time difference enables the approximation of the inconvenience the ridesharing is for the participants in the potential match.
From the driver's perspective, the route starts at the normal time minus the detour duration to still make it on the usual time.
This makes the detour the only inconvenience, in regards to time.
If the passenger has to arrive earlier than otherwise, the driver would also have to take that into consideration making the inconvenience not only the detour but also the relative time.

From the passenger's perspective, the opposite is true when it comes to the relative time. 
It is only an inconvenience when the driver must set them off before they need to arrive.

It is also worth noting that if the relative time is the same as the detour time, the only inconvenience for the driver is the detour.

The formula for the total inconvenience when taking both participants into account is then defined as the following:

\[ |d - t| + d \]

where $d$ is the detour and $t$ is the relative time.

\iffalse
Now, let us consider what would happen on the return route.
The situation is now that the driver and passenger want to return to their original locations, but they want to leave at a specific time.
The algorithm already solves this because if a specific arrival time is defined a specific departure time must also be defined.
And the differences in time must be the same.
\fi

\begin{algorithm}
	\caption{The Time Analyser pseudocode}
	\label{alg:timeanalyser}
	\begin{algorithmic}[1]
		\Require 
		\Statex let $\delta$ be the acceptable time difference in $\mathbb{R}_{>0}$
		\Statex let $\gamma$ be the translation from distance to time in $\mathbb{R}_{>0}$ 
		\Statex 
		\Function{TimeAnalyser}{$r, s, g$}
			\State let $r_s$ be the closest point to $s$ in $r$
			\State let $r_g$ be the closest point to $g$ in $r$
			\State $d \gets (2\times dist(r_s,s) + 2\times dist(r_g,g))\times\gamma$\Comment{The total detour time}
			\State $t \gets max(time(r_s, s), time(r_g, g))$\Comment{The largest time difference}
			\State\Return $1-\frac{|d - t| + d}{\delta}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Algorithm \ref{alg:timeanalyser} shows the pseudocode for the time analyser algorithm.
Line 2 to 4 is reminiscent of line 2 to 5 in Algorithm \ref{alg:distanalyser} with the difference that it sums the detours and multiplies the result with the distance to time translation.
Line 5 takes the greatest time difference between the closest points.
The reason for choosing the greatest value again is the pessimistic approach, so that the delay will not be worse than that.


\todo{maybe fix/check up on complexty}
%The complexity is the same as in Algorithm \ref{alg:distanalyser} because of the similarity of the first few lines and the last lines are simple arithmetic operations. 
%The exceptions are $dist$, $time$, and $max$. 
%$time$ and $dist$ have already been described in detail in this and previous section and are considered to be $O(1)$ operations.
%$max$ takes in two values compares them and returns the largest of the two.
%This is also a constant operation and with that, we can determine that the time analyser algorithm is $O(|r|)$.

%This means that the main algorithm is $O(|r|)$, the number of locations in a route, which is equivalent to $O(n)$.\todo{what is n?}
