\subsection{Location Gathering}
The location gathering should as previously discussed be preformed seamlessly for the user and in the background without any user interaction necessary. 
This requires a some certain design requirements which will be presented in the following text. 

\subsubsection{Overall Design}
Some informal location tests in sprint 2 showed that polling locations with at hard intervals controlled by a timer proved difficult to get working reliable and thus we consider using the JobScheduler which does not provide hard time limit but should be reliable to work in an expected time frame, this will be discussed further in the implementation.
The app main activity is the default activity and thus it is the code herein that is run when the app is opened.
To execute the location gathering in the background service, the location gathering will be preformed in a background service. 
This background should be activated automatic from the main activity once that activity is run.
The service should the be run contentiously with some interval and preform several different task based on which sensor input the service receives. 
This first read the service should preform each time cycle is to poll the activity recognition method whether the value for \texttt{inVehicle} is above some threshold. 
When the threshold for \texttt{inVehicle} is exceeded the service should start requesting the user location, this should probably be done though the Google Play Service location API which Google recommends above the native Android location framework\cite{apploc}.
As long as the activity registers a users as driving the location should be polled with reasonable intervals.
These locations should then be collected into a group of locations representing the users route.
When the the activity recognition has not been registered as driving for  while we will consider the commute ended and thus the route building should be finalized and send to the server.  

\subsubsection{Polling frequency}
When decided the polling frequency of both the activity recognition and the location gathering it is a question of striking the right balance of an accuracy representing the users actual behavior while preforming a minimal battery drain.

Firstly we consider the first task of the location gathering service, the activity recognition.
Polling the activity should require less power than polling the location, however every computation and sensor polling drains the users valuable battery power and should thus be kept to a minimum.  




\iffalse
Main
-activate BGS
    BGS (always listening) "RideShareService"
    -register activity
    -if (change to driving): activate LBS *with GPS?
        LBS (listening while driving) "LocationUpdaterService"
        -cacheLocation every x min 
        - utilize isBetterLocation?
        -onDestroy: return cache
    -if (change to other): deactivate LBS + cache -> localDB
-send localDB/routes to astep
\fi